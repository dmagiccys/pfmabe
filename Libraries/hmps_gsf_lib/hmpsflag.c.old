/********************************************************************
 *
 * Module Name : HMPSFLAG
 *
 * Author/Date : J. S. Byrne / 25 Apr 1995
 *
 * Description :
 *
 * Restrictions/Limitations :
 *
 * Change Descriptions :
 * who	when	  what
 * ---	----	  ----
 *
 *
 * Classification : Unclassified
 *
 * References :
 *
 *
 * Copyright (C) Science Applications International Corp.
 ********************************************************************/

/* Get the necessary include files */
#include "gsf.h"
#include "hmpsflag.h"

/********************************************************************
 *
 * Function Name : testHMPSBeamFlag
 *
 * Description :
 *
 * Inputs :
 *
 * Returns : zero if this beam is not set to the flag, or
 *	     1 if it is.
 *
 *
 * Error Conditions :
 *
 ********************************************************************/
int
testHMPSBeamFlag(gsfSwathBathyPing *p, int beam, int flag)
{
    /* Make sure the beam flags array is allocated */
    if (p->beam_flags == (unsigned char *) NULL)
    {
	return (0);
    }

    /* Make sure the beam number is valid */
    if ((beam >= p->number_beams) || (beam < 0))
    {
	return (0);
    }

    if (flag == HMPS_IGNORE_NULL_BEAM)
    {
        if ((p->beam_flags[beam] & flag) == flag)
        {
            if (!(p->beam_flags[beam] & ~flag)) return (1);
        }
    }
    else
    {
        if ((p->beam_flags[beam] & flag) == flag) return (1);
    }

    return (0);
}

/********************************************************************
 *
 * Function Name : setHMPSBeamFlag
 *
 * Description :
 *
 * Inputs :
 *
 * Returns :
 *
 * Error Conditions :
 *
 ********************************************************************/
int
setHMPSBeamFlag (gsfSwathBathyPing *p, int beam, int flag)
{
    int category;

    /* Make sure the beam flags array is allocated */
    if (p->beam_flags == (unsigned char *) NULL)
    {
	return(-1);
    }

    /* Make sure the beam number is valid */
    if ((beam >= p->number_beams) || (beam < 0))
    {
	return(-1);
    }

    category = (flag & 0x03) + 1;
    switch (category)
    {
	case (HMPS_INFORMATIONAL):
	    p->beam_flags[beam] |= flag;
	    break;

	case (HMPS_IGNORE):
	    p->beam_flags[beam] |= flag;
	    break;

	case (HMPS_SELECT):
	    /* Selected is exclusive of informational and ignore */
	    if (((p->beam_flags[beam] & 0x03) != 1) &&
		 (p->beam_flags[beam] != HMPS_INFO_NOT_1X_IHO))
	    {
		/* Set the appropiate bit mask */
		p->beam_flags[beam] |= flag;
	    }
	    else
	    {
		return(-1);
	    }
	    break;
    }
    return(0);
}

/********************************************************************
 *
 * Function Name : clearHMPSBeamFlag
 *
 * Description :
 *
 * Inputs :
 *
 * Returns :
 *
 * Error Conditions :
 *
 ********************************************************************/
int
clearHMPSBeamFlag (gsfSwathBathyPing *p, int beam, int category, int flag)
{
    unsigned char cMask;
    unsigned char reasons;
    unsigned char clear_bit;

    /* Make sure the beam flags array is allocated */
    if (p->beam_flags == (unsigned char *) NULL)
    {
	return(-1);
    }

    /* Make sure the beam number is valid */
    if ((beam >= p->number_beams) || (beam < 0))
    {
	return(-1);
    }

    /* switch on the category for this flag */
    switch (category)
    {
	case (HMPS_INFORMATIONAL):
	    p->beam_flags[beam] &= ~flag;
	    break;

	case (HMPS_IGNORE):
	    if ((p->beam_flags[beam] & 0x03) == 1)
	    {
		/* Save the category mask, and check to see if more than one
		 * of the ignore bits is set, if so don't clear the category
		 * mask.
		 */
		cMask = p->beam_flags[beam] & 0x03;
		reasons = p->beam_flags[beam] & HMPS_IGNORE_BIT_MASK;
		clear_bit = flag & ~(0x03);
		reasons &= ~clear_bit;
		if (reasons)
		{
		    p->beam_flags[beam] &= ~flag;
		    p->beam_flags[beam] |= cMask;
		}
		else
		{
		    p->beam_flags[beam] &= ~flag;
		}
		/* If this is a null beam then leave the ignore flag set */
		if (p->depth[beam] == 0.0)
		{
		    setHMPSBeamFlag (p, beam, HMPS_IGNORE_NULL_BEAM);
		}
	    }
	    else
	    {
		return(-1);
	    }
	    break;

	case (HMPS_SELECT):
	    if ((p->beam_flags[beam] & 0x03) == 2)
	    {
		p->beam_flags[beam] &= ~flag;
	    }
	    else
	    {
		return(-1);
	    }
	    break;
    }
    return(0);
}
